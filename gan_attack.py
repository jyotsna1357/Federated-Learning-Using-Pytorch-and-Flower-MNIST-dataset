import torch
import torch.nn as nn
import torch.optim as optim

# Basic Generator Network
class Generator(nn.Module):
    def __init__(self, input_size, output_size):
        super(Generator, self).__init__()
        self.fc = nn.Sequential(
            nn.Linear(input_size, 128),
            nn.ReLU(),
            nn.Linear(128, 256),
            nn.ReLU(),
            nn.Linear(256, output_size),
            nn.Tanh()
        )

    def forward(self, z):
        return self.fc(z)

# Basic Discriminator Network
class Discriminator(nn.Module):
    def __init__(self, input_size):
        super(Discriminator, self).__init__()
        self.fc = nn.Sequential(
            nn.Linear(input_size, 256),
            nn.ReLU(),
            nn.Linear(256, 128),
            nn.ReLU(),
            nn.Linear(128, 1),
            nn.Sigmoid()
        )

    def forward(self, x):
        return self.fc(x)

# GAN Attack Class
class GANAttack:
    def __init__(self, client_model, latent_dim=100, data_size=784):
        """
        Args:
            client_model: The model being used by the client.
            latent_dim: The size of the noise input for the generator.
            data_size: The size of the input data (e.g., 28x28 for MNIST flattened).
        """
        self.client_model = client_model
        self.latent_dim = latent_dim
        self.data_size = data_size
        
        # Initialize the GAN components
        self.generator = Generator(latent_dim, data_size)
        self.discriminator = Discriminator(data_size)

        # Optimizers for the GAN components
        self.g_optimizer = optim.Adam(self.generator.parameters(), lr=0.0002)
        self.d_optimizer = optim.Adam(self.discriminator.parameters(), lr=0.0002)
        
        # Loss function for GAN
        self.loss_fn = nn.BCELoss()
        
    def train_gan(self, real_data, num_epochs=100):
        """
        Train the GAN to reconstruct data.
        
        Args:
            real_data: The actual data from the client.
            num_epochs: Number of epochs to train the GAN.
        """
        batch_size = real_data.size(0)

        for epoch in range(num_epochs):
            # --- Train Discriminator ---
            # Generate fake data
            z = torch.randn(batch_size, self.latent_dim)
            fake_data = self.generator(z)
            
            # Discriminator real/fake labels
            real_labels = torch.ones(batch_size, 1)
            fake_labels = torch.zeros(batch_size, 1)
            
            # Discriminator loss on real and fake data
            self.d_optimizer.zero_grad()
            real_output = self.discriminator(real_data)
            fake_output = self.discriminator(fake_data.detach())
            
            real_loss = self.loss_fn(real_output, real_labels)
            fake_loss = self.loss_fn(fake_output, fake_labels)
            
            d_loss = real_loss + fake_loss
            d_loss.backward()
            self.d_optimizer.step()

            # --- Train Generator ---
            self.g_optimizer.zero_grad()
            fake_output = self.discriminator(fake_data)
            g_loss = self.loss_fn(fake_output, real_labels)  # We want to fool the discriminator
            g_loss.backward()
            self.g_optimizer.step()

            if epoch % 10 == 0:
                print(f"Epoch [{epoch}/{num_epochs}] | D Loss: {d_loss.item()} | G Loss: {g_loss.item()}")

    def apply(self, real_data):
        """
        Apply the GAN attack to reconstruct user data.
        
        Args:
            real_data: The real data from the client.
        
        Returns:
            reconstructed_data: The data generated by the GAN.
        """
        # Train GAN using the client's real data
        self.train_gan(real_data, num_epochs=100)

        # Generate synthetic data (reconstructed data)
        batch_size = real_data.size(0)
        z = torch.randn(batch_size, self.latent_dim)
        reconstructed_data = self.generator(z)
        
        return reconstructed_data
